<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>常见面试题 &mdash; MF</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/css/markdown/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mfuu.github.io/2020/02/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="alternate" type="application/atom+xml" title="MF" href="https://mfuu.github.io/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/favicon.ico"><meta property="og:title" content="常见面试题"><meta property="twitter:title" content="常见面试题"><meta name="keywords" content="面试题"><meta name="og:keywords" content="面试题"><meta name="description" content="从 URL 输入，到页面完全展示，都经历了什么？"><meta name="og:description" content="从 URL 输入，到页面完全展示，都经历了什么？"><meta name="twitter:description" content="从 URL 输入，到页面完全展示，都经历了什么？"><meta property="og:url" content="https://mfuu.github.io/2020/02/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><meta property="og:site_name" content="MF"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="twitter:url" content="https://mfuu.github.io/2020/02/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><meta property="twitter:site_name" content="MF"><meta property="article:published_time" content="2020-02-02"> <script src="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"> <button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <svg viewBox="0 0 18 15" width="18px" height="15px"><path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path> </svg> </button><nav class="site-header-nav" role="navigation"> <a href="https://mfuu.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://mfuu.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://mfuu.github.io/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://mfuu.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav><div class="site-title mobile-visible" title="POST">POST</div><div class="site-header-oprate"><div class="site-search"> <span class="octicon-search mobile-visible" onclick="mobileSearch(this);"></span> <input id="search_box" class="mobile-search-hidden" type="text" placeholder="Search" ><ul id="search_results"></ul></div><script src="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> function mobileSearch(node) { var search = $('#search_box'); if (search.hasClass('mobile-search-hidden')) { search.removeClass('mobile-search-hidden'); } else { search.addClass('mobile-search-hidden'); } if (node.style.right == '5px') { node.style.right = '0px'; } else { node.style.right = '5px'; } }; SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://mfuu.github.io/assets/search_data.json?v=1659772634', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: '<p>No results found</p>', limit: '10', fuzzy: false, exclude: ['Welcome'] }); </script></div></div></header><main class="site-container"><section class="collection-head small" data-pattern-id="常见面试题"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">常见面试题</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/02/02 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://mfuu.github.io/categories/#面试题" title="面试题">面试题</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 7580 字，约 22 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="从-url-输入到页面完全展示都经历了什么">从 URL 输入，到页面完全展示，都经历了什么？</h2><p>总的来说有以下过程：</p><ul><li>DNS 域名解析</li><li>发起 TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li></ul><h3 id="url-编码-dns-域名解析">URL 编码， DNS 域名解析</h3><p><strong>URL 编码</strong></p><p>网络标准规定 URL 只能是字母和数字，还有一些特殊符号 <code class="language-plaintext highlighter-rouge">（-_.~ ! * ' ( ) ; : @ &amp; = + $ , / ? # [ ]</code>，如果不进行转义，就会出现歧义（编码规则 utf-8）</p><p><strong>DNS 解析</strong></p><p>DNS 解析就是 URL 和 IP 地址的转换。比如输入地址 <code class="language-plaintext highlighter-rouge">www.google.com</code></p><ul><li><ol><li>检查浏览器缓存中是否缓存过该域名对应的 IP 地址</li></ol></li><li><ol><li>如果在浏览器缓存中未找到，继续查找本机系统 hosts 是否缓存过 IP</li></ol></li><li><ol><li>向本地域名解析服务器发起域名解析请求</li></ol></li><li><ol><li>向根域名解析服务器发起域名解析请求（<code class="language-plaintext highlighter-rouge">.com</code>）</li></ol></li><li><ol><li>向顶级域名服务器发起域名解析请求（<code class="language-plaintext highlighter-rouge">google.com</code>）</li></ol></li><li><ol><li>向主域名服务器发起域名解析请求（<code class="language-plaintext highlighter-rouge">www.google.com</code>）</li></ol></li></ul><p>1、2 为递归查询，3-6 为迭代查询</p><p><strong>DNS 负载均衡</strong></p><p>DNS 负载均衡的实现原理是在 DNS 服务器中为同一主机名配置多个 IP 地址，在应答 DNS 查询时，DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，也就是返回不同的 IP 地址，从而把访问引导到不同的服务器上去，来达到负载均衡的目的。</p><h3 id="tcp-连接">TCP 连接</h3><ul><li>URG：紧急标志。 <code class="language-plaintext highlighter-rouge">URG = 1</code> 时生效</li><li>ACK：确认标志。<code class="language-plaintext highlighter-rouge">ACK = 1</code>时，确认号字段才有效，TCP 规定，在建立连接后所有报文的传输都必须把 ACK 置为 1</li><li>SYN：同步标志。建立连接时用来同步序号，<code class="language-plaintext highlighter-rouge">SYN = 1, ACK = 0</code> 时表明是连接请求报文，响应报文中应为 <code class="language-plaintext highlighter-rouge">SYN = 1, ACK = 1</code></li><li>FIN：结束标志。用来释放连接，<code class="language-plaintext highlighter-rouge">FIN == 1</code> 时，表示此报文的发送方的数据已经发送完毕，要求释放</li></ul><blockquote><p><code class="language-plaintext highlighter-rouge">ACK</code> 与 <code class="language-plaintext highlighter-rouge">ack(确认号字段)</code> 需要区分开</p></blockquote><h4 id="三次握手">三次握手</h4><p><img src="https://user-images.githubusercontent.com/51625532/154204663-c92c4941-069f-40b0-b424-dd76299c6be3.jpg" alt="tcp-link" /></p><ul><li>第一次握手：客户端发送携带 <code class="language-plaintext highlighter-rouge">SYN = 1, Seq = x(x 为随机数)</code> 的数据包到服务器，进入 <code class="language-plaintext highlighter-rouge">SYN_SEND</code> 状态，等待服务器确认。（第一次握手由浏览器发起，告诉服务器，我要发送请求了）</li><li>第二次握手：服务器返回一个带 <code class="language-plaintext highlighter-rouge">SYN = 1, ACK = 1, ack = x + 1, Seq = y</code> 的响应包，此时服务器进入 <code class="language-plaintext highlighter-rouge">SYN_RECV</code> 状态。（第二次握手由服务器发起，告诉浏览器准备接收了）</li><li>第三次握手：客户端收到后会检查 <code class="language-plaintext highlighter-rouge">ack</code> 是否正确（=== x + 1 ?），如果正确，回传一个带 <code class="language-plaintext highlighter-rouge">ACK = 1, ack = y + 1, Seq = z</code> 的数据包，客户端和服务器进入 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> 状态</li></ul><blockquote><p>握手过程中传送的包中不包含数据，三次握手完毕后，客户端和服务器才正式建立连接。</p></blockquote><p><strong>为什么采用三次握手（TCP 的可靠传输）</strong></p><p>客户端和服务器要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手确认客户端的发送能力；第二次握手 <code class="language-plaintext highlighter-rouge">SYN = 1, Seq = y</code> 确认了服务器的发送能力，<code class="language-plaintext highlighter-rouge">ACK = x + 1</code> 确认了服务器的接收能力；第三次握手确认客户端的接收能力。</p><p>采用三次握手是为了防止失效的连接请求报文突然又发送给服务器，从而产生错误。例如：客户端发出的连接请求没有收到服务器的确认，于是一段时间后，客户端重新向服务器发送连接请求，并且成功建立连接。此时客户端第一次发送的连接请求并没有丢失，而是因为网络波动导致延迟到达服务器，服务器以为客户端又发起了连接请求，于是同一连接，向客户端发送确认信息，但是客户端并不会理会，服务器就一直等待客户端发送数据，导致资源浪费。</p><h4 id="四次挥手">四次挥手</h4><p><img src="https://user-images.githubusercontent.com/51625532/154208235-64e2609d-aa90-4a8a-bd92-cd48cd233f8b.jpg" alt="tcp-close" /></p><ul><li>第一次挥手：客户端发送带 <code class="language-plaintext highlighter-rouge">FIN = 1, Seq = u</code> 的包到服务器，用来关闭客户端到服务器的数据传输，客户端进入 FIN_WAIT_1 状态</li><li>第二次挥手：服务器收到 FIN 后，发送一个带 <code class="language-plaintext highlighter-rouge">ACK = 1, ack = u + 1, Seq = v</code> 的包给客户端，确认序号为收到序号 + 1，客户端进入 CLOSE_WAIT 状态</li><li>第三次挥手：服务器发送一个带 <code class="language-plaintext highlighter-rouge">FIN = 1, ACK = 1, ack = u + 1, Seq = w</code> 的包给客户端，用来关闭服务器到客户端的数据传输，服务器进入 LAST_ACK 状态</li><li>第四次挥手：客户端收到 FIN 后进入 TIME_WAIT 状态，接着发送一个带 <code class="language-plaintext highlighter-rouge">ACK = 1, ack = w + 1, Seq = u + 1</code> 的包给服务器。注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，服务器进入 CLOSED 状态。</li></ul><p><strong>为什么客户端最后要等待2MSL</strong></p><ul><li>保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，即保证 TCP 协议的全双工连接能可靠关闭。</li><li>防止已失效的连接请求报文段出现在本次连接中，即保证本次连接的重复数据段从网络中消失。</li></ul><h3 id="发送-http-请求">发送 HTTP 请求</h3><blockquote><p>强制缓存的优先级高于协商缓存，若两种缓存皆存在，且强制缓存命中目标，则协商缓存不再验证标识</p></blockquote><h4 id="http-缓存--强缓存">HTTP 缓存 ———— 强缓存</h4><p>缓存命中：</p><p>客户端请求数据，如果缓存数据库中有客户端需要的数据并且未过期，则使用缓存中的数据</p><p>缓存未命中：</p><p>客户端请求数据，如果缓存数据库中的缓存数据失效，则向服务器发起请求，服务器返回数据给客户端，客户端将数据和缓存规则存入缓存系统</p><p><strong>cache-control</strong></p><p>通过 <code class="language-plaintext highlighter-rouge">cache-control</code> 设置 max-age=xxx 默认为 private</p><ul><li>private：私有缓存</li><li>public：共享缓存</li><li>max-age：缓存的内容将在 xxx 秒后失效。<code class="language-plaintext highlighter-rouge">max-age=0</code> 表示不管 response 怎么设置，在重新获取资源之前，先检验 <code class="language-plaintext highlighter-rouge">ETag/Last-Modified</code>。不管是max-age=0还是no-cache，都会返回304（资源无修改的情况下）</li><li>no-cahce：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的协商缓存</li><li>no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源</li></ul><h4 id="http-缓存--协商缓存">HTTP 缓存 ———— 协商缓存</h4><p>缓存命中：</p><p>客户端从缓存数据库中拿到一个缓存标识，然后向服务器验证缓存标识对应的数据是否失效，如果没有失效服务器会返回304，客户端直接去缓存数据库拿数据。</p><p>缓存未命中：</p><p>客户端从缓存数据库中拿到一个缓存标识，然后向服务器验证缓存标识对应的数据是否失效，如果失效，服务器返回最新的数据和缓存规则，客户端将数据和缓存规则存入缓存系统</p><p><strong>Last-Modified</strong></p><p>服务器在响应请求时，会告诉浏览器资源的最后修改时间</p><ul><li>if-Modified-Since：浏览器再次请求服务器的时候，请求头会包含该字段，后面跟着在缓存中获得的最后修改时间。服务器收到此请求头发现有 <code class="language-plaintext highlighter-rouge">if-Modified-Since</code>，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可，如果不一致则返回 200 和新的 <code class="language-plaintext highlighter-rouge">last-modified</code> 和文件。</li><li>if-Unmodified-Since：从某个时间点算起，资源是否未被修改</li></ul><p><strong>Etag</strong></p><p>服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识</p><ul><li>if-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到报文后发现 <code class="language-plaintext highlighter-rouge">if-None-Match</code>，则与被请求资源的唯一标识进行对比<ul><li>不同：说明资源被修改过，响应整个资源内容，返回 200</li><li>相同：说明资源未被修改，响应 header，返回 304，浏览器直接从缓存中获取数据</li></ul></li></ul><h4 id="启发式缓存">启发式缓存</h4><table><tbody><tr><td>如果响应中未显示 Expires、Cache-Control: max-age</td><td>s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜的寿命。通常会根据响应头中的 Date（创建报文的时间） 减去 Last-Modified（资源最后被修改的时间） 的值的 10% 作为缓存时间</td></tr></tbody></table><h3 id="服务器处理请求并返回">服务器处理请求并返回</h3><h3 id="浏览器解析渲染页面">浏览器解析渲染页面</h3><h3 id="参考文章">参考文章：</h3><p><a href="https://juejin.cn/post/6844903832435032072">史上最详细的经典面试题 从输入URL到看到页面发生了什么？</a></p><h2 id="v8-引擎的垃圾回收机制">V8 引擎的垃圾回收机制</h2><h3 id="垃圾回收策略">垃圾回收策略</h3><p>v8 的垃圾回收策略主要是基于 <code class="language-plaintext highlighter-rouge">分代式垃圾回收机制</code>，根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不用的分代采用不同的垃圾回收算法</p><h4 id="新生代">新生代</h4><h4 id="老生代">老生代</h4><h4 id="标记清除算法">标记清除算法</h4><p>标记清除算法大致过程：</p><ul><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li><li>然后从根对象开始遍历，把不是垃圾的节点改成1</li><li>清理所有标记为 0 的垃圾，销毁并回收它们所占的内存空间</li><li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收</li></ul><p>优点：</p><p>标记清除算法优点只有一个，就是实现比较简单，只需要标记和未标记两种状态</p><p>缺点：</p><p>在垃圾清除后，剩余的对象内存位置不变，导致空闲内存空间是不连续的，出现了内存碎片。（标记整理算法可以有效解决，在标记结束后，标记整理算法会将活着的对象向内存的一端移动，最后清理掉边界的内存）</p><h4 id="引用计数算法">引用计数算法</h4><p>引用计数把对象是否不再需要简化定义为对象有没有其他对象引用到它，如果没有引用指向该对象，对象将被垃圾回收机制回收。它的策略是跟踪记录每个变量被使用的次数</p><ul><li>当声明了一个变量并且将一个引用类型赋值给变量的时候，这个值的引用次数就为 1</li><li>如果同一个值又被赋给另一个变量，那么引用次数加 1</li><li>如果该变量的值被其他的值覆盖，引用次数减 1</li><li>当变量的引用次数为 0 时，说明这个值没被访问，垃圾回收器在运行时会清理掉引用次数为 0 的值占的内存</li></ul><p>优点：</p><p>引用值为 0 时就会被回收，不需要像标记清除算法每隔一段时间进行一次；标记清除算法需要遍历堆里的活动和非活动对象，引用计数只需要在引用时计算引用次数即可</p><p>缺点：</p><p>无法解决循环引用问题；需要一个计数器，需要占很大的位置</p><hr /><h2 id="二叉树的深度遍历和广度遍历">二叉树的深度遍历和广度遍历</h2><p><a href="https://mfuu.github.io/2022/03/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95/#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">二叉树的深度遍历和广度遍历</a></p><h2 id="http20">HTTP2.0</h2><h3 id="与-http1x-相比的新特性">与 HTTP1.x 相比的新特性</h3><blockquote><p>二进制传输</p></blockquote><p>HTTP 2.0 中所有加强性能的核心点在于此。在此之前的 HTTP 版本中，都是通过文本的方式传输数据，在 HTTP 2.0 中引入了新的编码机制，所有的传输数据都会被分割，并采用二进制格式编码。</p><blockquote><p>多路复用</p></blockquote><p>在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求（在一个 TCP 上并行地发送任意数量 HTTP 请求），对端可以通过帧中的标识知道属于哪个请求。通过这种技术，可以避免 HTTP 旧版本中的对头阻塞问题，极大的提高传输性能。这个强大的功能则是基于“二进制分帧”的特性。</p><blockquote><p>header 压缩</p></blockquote><p>在 HTTP 1.x 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p><blockquote><p>服务器推送</p></blockquote><p>允许服务器在发送页面 HTML 时主动推送其他资源，而不用等到浏览器解析到相应位置，发起请求再响应。</p><p>例如：服务端主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。</p><p>服务器可以主动推送，客户端也可以选择是否接收。</p><h2 id="react-与-vue-的区别">React 与 Vue 的区别</h2><h3 id="数据">数据</h3><ul><li><p>React 整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在 React 中，是单向数据流，推崇结合 <code class="language-plaintext highlighter-rouge">immutable</code> 来实现数据不可变。React 在 <code class="language-plaintext highlighter-rouge">setState</code> 之后会重新走渲染的流程，如果 <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code> 返回的是 <code class="language-plaintext highlighter-rouge">true</code>，就继续渲染，如果是 <code class="language-plaintext highlighter-rouge">false</code>，就不会重新渲染。<code class="language-plaintext highlighter-rouge">PureComponent</code> 就是重写了 <code class="language-plaintext highlighter-rouge">shouldComponentUpdate</code>，然后在里面做了 props 和 state 的浅层对比。</p></li><li><p>Vue 的思想是响应式的，也就是基于数据可变。通过对每一个属性建立 Watcher 来监听，当属性变化时，响应式的更新对应的虚拟 dom。</p></li></ul><p>总的来说，React 的性能优化需要手动去做，而 Vue 的性能优化是自动的，但是 Vue 的响应式机制也有问题，当 state 特别多的时候，Watcher 也会很多，会导致卡顿。</p><h3 id="模板和-jsx">模板和 JSX</h3><ul><li><p>React 的思路是全部通过 js 来实现，通过 js 来生成 html，所以设计了 JSX，还有通过 js 来操作 css（styled-component、jss 等）</p></li><li><p>Vue 是把 html、css、js 组合到一起，用各自的处理方式，Vue 有单文件组件，可以把 html、css、js 写到一个文件中，html 提供了模板引擎来处理</p></li></ul><h3 id="diff-算法不同">Diff 算法不同</h3><h3 id="响应式原理不同">响应式原理不同</h3><ul><li><p>React 的响应式原理：通过 <code class="language-plaintext highlighter-rouge">setState()</code> 方法来更新状态，状态更新后，组件也会重新渲染</p></li><li><p>Vue 的响应式原理：Vue 会遍历 data 数据对象，使用 <code class="language-plaintext highlighter-rouge">Object.definedProperty()</code> 将每个属性转为 <code class="language-plaintext highlighter-rouge">getter</code> 和 <code class="language-plaintext highlighter-rouge">setter</code>，每个 Vue 组件实例都有一个对应的 watcher 实例，在组件初次渲染的时候会记录组件用到了哪些数据，当数据发生变化时，会触发 <code class="language-plaintext highlighter-rouge">setter</code> 方法，并通知所有依赖这个数据的 watcher 实例调用 <code class="language-plaintext highlighter-rouge">update</code> 方法去触发组件的 <code class="language-plaintext highlighter-rouge">compile</code> 渲染方法，进行数据渲染</p></li></ul><h3 id="总结">总结</h3><p>React 整体的思路就是函数式，所以推崇纯组件，数据不可变，单向数据流。 Vue 是基于可变数据，支持双向绑定。</p><h2 id="typescript-与-javascript-的区别">TypeScript 与 JavaScript 的区别</h2><h3 id="typescript-的特点">TypeScript 的特点</h3><p>相较于JS（ES6+）</p><ul><li>TS 是 JS 的超集，即你可以在 TS 中使用原生 JS 语法</li><li>TS 需要静态编译，它提供了强类型与更多面向对象的内容</li><li>TS 最终仍需要编译为弱类型的 JS 文件，基于对象的原生 JS，再运行</li></ul><h3 id="区别">区别</h3><p>| JavaScript | TypeScript | | ———- | ———- | | <strong>动态类型</strong>，运行时明确变量的类型，变量的类型由变量的值决定，并跟随值的变化改变 | <strong>静态类型</strong>，声明时确定类型，之后不允许修改 | | <strong>直接运行</strong>在浏览器和 node 环境中 | <strong>编译运行</strong>，始终先编译成 JavaScript 再运行 | | <strong>弱类型</strong>，数据类型可以被忽略，一个变量可以赋不同数据类型的值 | <strong>强类型</strong>，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型 |</p><h2 id="event-loop">Event Loop</h2><ol><li>代码开始执行，创建一个全局调用栈，script作为宏任务执行</li><li>执行过程过同步任务立即执行，异步任务根据异步任务类型分别注册到微任务队列和宏任务队列</li><li>同步任务执行完毕，查看微任务队列</li><li>若存在微任务，将微任务队列全部执行(包括执行微任务过程中产生的新微任务)</li><li>若无微任务，查看宏任务队列，执行第一个宏任务，宏任务执行完毕，查看微任务队列，重复上述操作，直至宏任务队列为空</li></ol><ul><li><a href="https://github.com/mfuu/Blog/issues/2">深入理解js事件循环机制（Node.js）</a></li><li><a href="https://github.com/mfuu/Blog/issues/3">深入理解js事件循环机制（浏览器）</a></li></ul><h2 id="vue-创建到销毁的全过程">Vue 创建到销毁的全过程</h2><p><a href="https://mfuu.github.io/2022/03/05/vue-%E5%88%9B%E5%BB%BA%E5%88%B0%E9%94%80%E6%AF%81%E5%85%A8%E8%BF%87%E7%A8%8B/">vue-创建到销毁全过程</a></p><h2 id="手动实现-eventbus">手动实现 EventBus</h2><p>https://developer.aliyun.com/article/975490</p><h2 id="cookie">Cookie</h2><h3 id="设置-cookie">设置 Cookie</h3><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">CookieUtil</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="kd">set</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">expiresOrMaxAge</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">secure</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">cookieText</span> <span class="o">=</span> <span class="s2">`</span><span class="p">${</span><span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">)}</span><span class="s2">=</span><span class="p">${</span><span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">value</span><span class="p">)}</span><span class="s2">`</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">expiresOrMaxAge</span> <span class="k">instanceof</span> <span class="nb">Date</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">`; expires=</span><span class="p">${</span><span class="nx">expiresOrMaxAge</span><span class="p">.</span><span class="nx">toGMTString</span><span class="p">()}</span><span class="s2">`</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">expiresOrMaxAge</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">`; max-age=</span><span class="p">${</span><span class="nx">expiresOrMaxAge</span><span class="p">}</span><span class="s2">`</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">`; path=</span><span class="p">${</span><span class="nx">path</span><span class="p">}</span><span class="s2">`</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">domain</span><span class="p">)</span> <span class="nx">cookieText</span> <span class="o">+=</span> <span class="s2">`; domain=</span><span class="p">${</span><span class="nx">domain</span><span class="p">}</span><span class="s2">`</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">secure</span><span class="p">)</span> <span class="nx">cookieText</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">; secure</span><span class="dl">'</span>

    <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="nx">cookieText</span>
  <span class="p">}</span>
  <span class="kd">static</span> <span class="nx">unset</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">secure</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">CookieUtil</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="dl">''</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">domain</span><span class="p">,</span> <span class="nx">secure</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>通过 <code class="language-plaintext highlighter-rouge">document.cookie</code> 属性设置新的 cookie 字符串。这个字符串在被解析后会添加到原有的 cookie 中，设置 <code class="language-plaintext highlighter-rouge">document.cookie</code> 不会覆盖之前任何 cookie，除非设置了已有的 cookie。设置 cookie 格式如下：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">name</span><span class="o">=</span><span class="nx">value</span><span class="p">;</span> <span class="nx">expires</span><span class="o">=</span><span class="nx">expiration_time</span><span class="p">;</span> <span class="nx">path</span><span class="o">=</span><span class="nx">domain_path</span><span class="p">;</span> <span class="nx">domain</span><span class="o">=</span><span class="nx">domain_name</span><span class="p">;</span> <span class="nx">secure</span>

<span class="c1">// or</span>

<span class="nx">name</span><span class="o">=</span><span class="nx">value</span><span class="p">;</span> <span class="nx">max</span><span class="o">-</span><span class="nx">age</span><span class="o">=</span><span class="nx">max_age_time</span><span class="p">;</span> <span class="nx">path</span><span class="o">=</span><span class="nx">domain_path</span><span class="p">;</span> <span class="nx">domain</span><span class="o">=</span><span class="nx">domain_name</span><span class="p">;</span> <span class="nx">secure</span>
</code></pre></div></div><p>所有的参数中，只有 cookie 的 name 和 value 是必须的，且 name 和 value 必须使用 <code class="language-plaintext highlighter-rouge">encodeURIComponent()</code> 进行编码</p><h4 id="可选字段">可选字段</h4><p><strong>expires</strong>, <strong>max-age</strong></p><p>默认情况下，如果一个 cookie 没有设置这两个参数中的任何一个，那么在关闭浏览器后，该 cookie 数据就会被删除。此类的 cookie 被称为 <code class="language-plaintext highlighter-rouge">session cookie</code></p><p>为了控制 cookie 的有效期，需要设置 <code class="language-plaintext highlighter-rouge">expires</code> 或 <code class="language-plaintext highlighter-rouge">max-age</code></p><ul><li>expires: 定义 cookie 过期的时间，时间采用 GMT 格式</li><li>max-age: 定义 cookie 有效的时间，纯数字，单位为秒</li></ul><p><strong>path</strong></p><p>path 必须是绝对路径。它使得该路径下的页面都可以访问该 cookie。默认为当前路径</p><p>如果一个 cookie 带有 <code class="language-plaintext highlighter-rouge">path=/admin</code>，那么该 cookie 在 <code class="language-plaintext highlighter-rouge">/admin</code> 和 <code class="language-plaintext highlighter-rouge">/admin/xxx</code> 下都是可见的，但是在 <code class="language-plaintext highlighter-rouge">/front</code> 下不可见</p><p>通常，我们应该将 path 设置为根目录：<code class="language-plaintext highlighter-rouge">path=/</code>，以使 cookie 对此网站的所有页面可见</p><blockquote><p>设置 cookie 的 path 时，可以是任意绝对路径，不受当前页面 URL 路径的影响，且都有效</p></blockquote><p><strong>domain</strong></p><p>cookie 的有效域（域名不包含协议和端口）</p><p>发送到这个域的所有请求都会包含对应的 cookie。这个值可能包含子域（如www.baidu.com），也可以不包含（如.baidu.com 表示对 baidu.com 的所有子域都有效）。如果不明确设置，则默认为设置 cookie 的当前页面的域</p><p><strong>secure</strong></p><p>默认情况下，cookie 是不会区分协议的，http 协议和 https 协议都可以使用 cookie 数据</p><p>当设置 cookie 的数据中存在 <code class="language-plaintext highlighter-rouge">secure</code> 标识时，则只有 https 协议可以使用该条 cookie 数据</p><h3 id="删除-cookie">删除 Cookie</h3><p>没有直接删除已有 cookie 的方法。为此，需要再次设置同名 cookie（包括相同path、domain、secure），但要将其过期时间设置为某个过去的时间</p></article><div class="share"><div class="share-component" data-disabled='douban,linkedin'></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2020/02/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E', clientID: '425281566fa2c21accf0', clientSecret: 'cc605a5d6af0c0564bbfe768ed4bebb2f4dd2a63', repo: 'mfuu.github.io', owner: 'mfuu', admin: ['mfuu'], labels: ['gitalk'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth sticky-nav"><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/js/jquery.toc.js"></script></div></div></section></main><footer class="site-footer"><div class="contact"><ul class="left"> <a href="https://github.com/mfuu/mfuu.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a> <a class="rss" href="https://mfuu.github.io/feed.xml"> <span class="octicon octicon-rss" title="Subscribe"></span> </a></ul><ul class="right"> <a href="javascript:window.scrollTo(0,0)" class="toTop" title="Scroll to top">TOP</a></ul></div><div class="footer" role="contentinfo"><div class="copyright left"> © 2019 <span title="mfuu">mfuu</span></div><div class="right text-align-right"> <script async src="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div> <span id="busuanzi_container_site_pv" style="display:none"> <span id="busuanzi_value_site_pv"></span>浏览 </span> <span id="busuanzi_container_site_uv" style="display:none"> &nbsp;/&nbsp; <span id="busuanzi_value_site_uv"></span>访客 </span></div></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"> <svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8=""><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8=""></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8=""></path></svg> </a></div><script src="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/mfuu/mfuu.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script> <script> jQuery(document).ready(function($) { function setContainerStyle(){ var footerH = $("footer").height(); $('.site-container').css('paddingBottom', `${footerH + 20}px`); } setContainerStyle(); $(window).resize(setContainerStyle()); }); </script></body></html><div class="progress-indicator"></div><script> jQuery(document).ready(function($) { var $w = $(window); var $prog2 = $('.progress-indicator'); var wh = $w.height(); var h = $('body').height(); var sHeight = h - wh; if (!window.requestAnimationFrame) { window.requestAnimationFrame = function(callback){ return setTimeout(callback, 17); }; }; $w.on('scroll', function() { window.requestAnimationFrame(function(){ var perc = Math.max(0, Math.min(1, $w.scrollTop() / sHeight)); updateProgress(perc); }); }); function updateProgress(perc) { $prog2.css({width: perc * 100 + '%'}); } setTimeout(() => { window.toTop && window.toTop() }, 0) }); </script>
