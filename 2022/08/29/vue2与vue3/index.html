<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Vue2 与 Vue3 &mdash; MF</title><link rel="stylesheet" href="https://mfuu.github.io/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/css/components/collection.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/css/globals/common.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/css/posts/index.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/css/markdown/native.css"><link rel="stylesheet" href="https://mfuu.github.io/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://mfuu.github.io/2022/08/29/vue2%E4%B8%8Evue3/"><link rel="alternate" type="application/atom+xml" title="MF" href="https://mfuu.github.io/feed.xml"><link rel="shortcut icon" href="https://mfuu.github.io/favicon.ico"><meta property="og:title" content="Vue2 与 Vue3"><meta property="twitter:title" content="Vue2 与 Vue3"><meta name="keywords" content="Vue, Vue3, Vue2"><meta name="og:keywords" content="Vue, Vue3, Vue2"><meta name="description" content="生命周期"><meta name="og:description" content="生命周期"><meta name="twitter:description" content="生命周期"><meta property="og:url" content="https://mfuu.github.io/2022/08/29/vue2%E4%B8%8Evue3/"><meta property="og:site_name" content="MF"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="twitter:url" content="https://mfuu.github.io/2022/08/29/vue2%E4%B8%8Evue3/"><meta property="twitter:site_name" content="MF"><meta property="article:published_time" content="2022-08-29"> <script src="https://mfuu.github.io/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://mfuu.github.io/assets/js/jquery-ui.js"></script> <script src="https://mfuu.github.io/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"> <button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <svg viewBox="0 0 18 15" width="18px" height="15px"><path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path> </svg> </button><nav id="site-header-nav" class="site-header-nav" role="navigation"> <a href="https://mfuu.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://mfuu.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://mfuu.github.io/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://mfuu.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav><div class="site-title mobile-visible" title="POST">POST</div><div class="site-header-oprate"><div id="site-search" class="site-search"> <span id="search-icon" class="octicon-search mobile-visible" onclick="mobileSearch(this);"></span> <input id="search_box" class="mobile-search-hidden" type="text" placeholder="Search" ><ul id="search_results"></ul></div><script src="https://mfuu.github.io/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> function mobileSearch(node) { var search = $('#search_box'); if (search.hasClass('mobile-search-hidden')) { search.removeClass('mobile-search-hidden'); } else { search.addClass('mobile-search-hidden'); } if (node.style.right == '5px') { node.style.right = '0px'; } else { node.style.right = '5px'; } }; SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://mfuu.github.io/assets/search_data.json?v=1663141303', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: '<li class="empty">No results found</li>', limit: '10', fuzzy: false, exclude: ['Welcome'] }); </script></div></div></header><main class="site-container"><section class="collection-head small" data-pattern-id="Vue2 与 Vue3"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Vue2 与 Vue3</h1><div class="collection-info"> <span class="meta-info inline-flex align-items-center"> <span class="octicon octicon-calendar"></span> 2022/08/29 </span> <span class="meta-info inline-flex align-items-center"> <span class="octicon octicon-file-directory"></span> <a href="https://mfuu.github.io/categories/#Vue" title="Vue">Vue</a> </span> <span class="meta-info inline-flex align-items-center"> <span class="octicon octicon-clock"></span> 共 6323 字，约 19 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h2 id="生命周期">生命周期</h2><table><thead><tr><th>Vue2.x</th><th>Vue3.x</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">beforeCreate</code></td><td><code class="language-plaintext highlighter-rouge">setup</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">created</code></td><td><code class="language-plaintext highlighter-rouge">setup</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">beforeMount</code></td><td><code class="language-plaintext highlighter-rouge">onBeforeMount</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">mounted</code></td><td><code class="language-plaintext highlighter-rouge">onMounted</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">beforeUpdate</code></td><td><code class="language-plaintext highlighter-rouge">onBeforeUpdate</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">updated</code></td><td><code class="language-plaintext highlighter-rouge">onUpdated</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">beforeDestroy</code></td><td><code class="language-plaintext highlighter-rouge">onBeforeUnmount</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">destroyed</code></td><td><code class="language-plaintext highlighter-rouge">onUnmounted</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">errorCaptured</code></td><td><code class="language-plaintext highlighter-rouge">onErrorCaptured</code></td></tr></tbody></table><p>整体来看变化不大，除了 <code class="language-plaintext highlighter-rouge">beforeCreate</code>、<code class="language-plaintext highlighter-rouge">created</code> 用 <code class="language-plaintext highlighter-rouge">setup</code> 代替外，其余的基本都是变更名称，但功能本质上未发生变化</p><h2 id="响应式原理">响应式原理</h2><h3 id="objectdefineproperty"><code class="language-plaintext highlighter-rouge">Object.defineProperty</code></h3><p>vue2 中无法实现对数组对象的深层监听，是因为组件每次渲染都是将 <code class="language-plaintext highlighter-rouge">data</code> 里的数据通过 <code class="language-plaintext highlighter-rouge">defineProperty</code> 进行响应式或者双向绑定，在此之前没有加上的属性是不会被绑定上的，也就不会触发更新渲染</p><div class="language-js highlighter-rouge"><div class="highlight">class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">Obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">enumerable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 可枚举</span>
  <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 可配置</span>

  <span class="na">get</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">def</span>
  <span class="p">},</span>
  <span class="na">set</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">def</span> <span class="o">=</span> <span class="nx">val</span>
  <span class="p">}</span>
<span class="p">})</span>
</pre></div></div><p>Vue2.x 针对数组的解决方案：对常用数组原型方法 <code class="language-plaintext highlighter-rouge">push</code>、<code class="language-plaintext highlighter-rouge">pop</code>、<code class="language-plaintext highlighter-rouge">shift</code>、<code class="language-plaintext highlighter-rouge">unshift</code>、<code class="language-plaintext highlighter-rouge">splice</code>、<code class="language-plaintext highlighter-rouge">sort</code>、<code class="language-plaintext highlighter-rouge">reverse</code> 进行了 hack 处理；并提供了 <code class="language-plaintext highlighter-rouge">Vue.set</code> 监听对象/数组新增属性。对象的新增/删除响应，还可以 <code class="language-plaintext highlighter-rouge">new</code> 一个新对象，新增则合并新属性和就对象，删除则将删除属性后的对象深拷贝给新对象。</p><blockquote><p><code class="language-plaintext highlighter-rouge">Object.defineProperty</code> 是可以监听数组已有元素的，但 Vue2 没有提供的原因是 <strong>性能问题</strong></p></blockquote><h3 id="proxy"><code class="language-plaintext highlighter-rouge">Proxy</code></h3><div class="language-js highlighter-rouge"><div class="highlight">class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">hanlder</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">get</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">prop</span> <span class="k">in</span> <span class="nx">obj</span> <span class="p">?</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">none</span><span class="dl">'</span>
  <span class="p">},</span>
  <span class="na">set</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{},</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">({},</span> <span class="nx">handler</span><span class="p">)</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="kc">undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// 1, undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span> <span class="k">in</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// false, 'none'</span>
</pre></div></div><p><code class="language-plaintext highlighter-rouge">defineProperty</code> 只能响应首次添加时的属性值，而 <code class="language-plaintext highlighter-rouge">Proxy</code> 监听的是整个数据整体，不需要关心里面有什么属性，而且 <code class="language-plaintext highlighter-rouge">Proxy</code> 的配置项丰富（一共13种），可以做更细致的事情</p><h2 id="diff-算法">Diff 算法</h2><p>搬运 Vue3 patchChildren 源码。结合上文与源码，patchFlag帮助 diff 时区分静态节点，以及不同类型的动态节点。一定程度地减少节点本身及其属性的比对。</p><div class="language-ts highlighter-rouge"><div class="highlight">class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">patchChildren</span><span class="p">(</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">parentAnchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 获取新老孩子节点</span>
  <span class="kd">const</span> <span class="nx">c1</span> <span class="o">=</span> <span class="nx">n1</span> <span class="o">&amp;&amp;</span> <span class="nx">n1</span><span class="p">.</span><span class="nx">children</span>
  <span class="kd">const</span> <span class="nx">c2</span> <span class="o">=</span> <span class="nx">n2</span><span class="p">.</span><span class="nx">children</span>
  <span class="kd">const</span> <span class="nx">prevShapeFlag</span> <span class="o">=</span> <span class="nx">n1</span> <span class="p">?</span> <span class="nx">n1</span><span class="p">.</span><span class="nx">shapeFlag</span> <span class="p">:</span> <span class="mi">0</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">patchFlag</span><span class="p">,</span> <span class="nx">shapeFlag</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">n2</span>
  
  <span class="c1">// 处理 patchFlag 大于 0 </span>
  <span class="k">if</span><span class="p">(</span><span class="nx">patchFlag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">patchFlag</span> <span class="o">&amp;&amp;</span> <span class="nx">PatchFlags</span><span class="p">.</span><span class="nx">KEYED_FRAGMENT</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 存在 key</span>
      <span class="nx">patchKeyedChildren</span><span class="p">()</span>
      <span class="k">return</span>
    <span class="p">}</span> <span class="nx">els</span> <span class="k">if</span><span class="p">(</span><span class="nx">patchFlag</span> <span class="o">&amp;&amp;</span> <span class="nx">PatchFlags</span><span class="p">.</span><span class="nx">UNKEYED_FRAGMENT</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 不存在 key</span>
      <span class="nx">patchUnkeyedChildren</span><span class="p">()</span>
      <span class="k">return</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// 匹配是文本节点（静态）：移除老节点，设置文本节点</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">shapeFlag</span> <span class="o">&amp;&amp;</span> <span class="nx">ShapeFlags</span><span class="p">.</span><span class="nx">TEXT_CHILDREN</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">prevShapeFlag</span> <span class="o">&amp;</span> <span class="nx">ShapeFlags</span><span class="p">.</span><span class="nx">ARRAY_CHILDREN</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">unmountChildren</span><span class="p">(</span><span class="nx">c1</span> <span class="k">as</span> <span class="nx">VNode</span><span class="p">[],</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">c2</span> <span class="o">!==</span> <span class="nx">c1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">hostSetElementText</span><span class="p">(</span><span class="nx">container</span><span class="p">,</span> <span class="nx">c2</span> <span class="k">as</span> <span class="kr">string</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 匹配新老 Vnode 是数组，则全量比较；否则移除当前所有的节点</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">prevShapeFlag</span> <span class="o">&amp;</span> <span class="nx">ShapeFlags</span><span class="p">.</span><span class="nx">ARRAY_CHILDREN</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">shapeFlag</span> <span class="o">&amp;</span> <span class="nx">ShapeFlags</span><span class="p">.</span><span class="nx">ARRAY_CHILDREN</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">patchKeyedChildren</span><span class="p">(</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">anchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,...)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">unmountChildren</span><span class="p">(</span><span class="nx">c1</span> <span class="k">as</span> <span class="nx">VNode</span><span class="p">[],</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      
      <span class="k">if</span><span class="p">(</span><span class="nx">prevShapeFlag</span> <span class="o">&amp;</span> <span class="nx">ShapeFlags</span><span class="p">.</span><span class="nx">TEXT_CHILDREN</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">hostSetElementText</span><span class="p">(</span><span class="nx">container</span><span class="p">,</span> <span class="p">)</span>
      <span class="p">}</span> 
      <span class="k">if</span> <span class="p">(</span><span class="nx">shapeFlag</span> <span class="o">&amp;</span> <span class="nx">ShapeFlags</span><span class="p">.</span><span class="nx">ARRAY_CHILDREN</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">mountChildren</span><span class="p">(</span><span class="nx">c2</span> <span class="k">as</span> <span class="nx">VNodeArrayChildren</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span><span class="nx">anchor</span><span class="p">,</span><span class="nx">parentComponent</span><span class="p">,...)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></div><h4 id="patchunkeyedchildren-源码如下">patchUnkeyedChildren 源码如下:</h4><div class="language-ts highlighter-rouge"><div class="highlight">class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">patchUnkeyedChildren</span><span class="p">(</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">parentAnchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">c1</span> <span class="o">=</span> <span class="nx">c1</span> <span class="o">||</span> <span class="nx">EMPTY_ARR</span>
  <span class="nx">c2</span> <span class="o">=</span> <span class="nx">c2</span> <span class="o">||</span> <span class="nx">EMPTY_ARR</span>
  <span class="kd">const</span> <span class="nx">oldLength</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">const</span> <span class="nx">newLength</span> <span class="o">=</span> <span class="nx">c2</span><span class="p">.</span><span class="nx">length</span>
  <span class="kd">const</span> <span class="nx">commonLength</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">oldLength</span><span class="p">,</span> <span class="nx">newLength</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">i</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">commonLength</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果新 Vnode 已经挂载，则直接 clone 一份，否则新建一个节点</span>
    <span class="kd">const</span> <span class="nx">nextChild</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">optimized</span> <span class="p">?</span> <span class="nx">cloneIfMounted</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="k">as</span> <span class="nx">Vnode</span><span class="p">))</span> <span class="p">:</span> <span class="nx">normalizeVnode</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="nx">patch</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">oldLength</span> <span class="o">&gt;</span> <span class="nx">newLength</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 移除多余的节点</span>
    <span class="nx">unmountedChildren</span><span class="p">()</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 创建新的节点</span>
    <span class="nx">mountChildren</span><span class="p">()</span>
  <span class="p">}</span>
  
<span class="p">}</span>
</pre></div></div><h4 id="patchkeyedchildren源码如下有运用最长递增序列的算法思想">patchKeyedChildren源码如下，有运用最长递增序列的算法思想:</h4><div class="language-ts highlighter-rouge"><div class="highlight">class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
</pre></td><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">patchKeyedChildren</span><span class="p">(</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">parentAnchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSVG</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">e1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kd">const</span> <span class="nx">e2</span> <span class="o">=</span> <span class="nx">c2</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="kd">const</span> <span class="nx">l2</span> <span class="o">=</span> <span class="nx">c2</span><span class="p">.</span><span class="nx">length</span>
  
  <span class="c1">// 从头开始遍历，若新老节点是同一节点，执行 patch 更新差异；否则，跳出循环 </span>
  <span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e1</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="kd">const</span> <span class="nx">n2</span> <span class="o">=</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    
    <span class="k">if</span><span class="p">(</span><span class="nx">isSameVnodeType</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">patch</span><span class="p">(</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">parentAnchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSvg</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="nx">i</span><span class="o">++</span>
  <span class="p">}</span>
  
  <span class="c1">// 从尾开始遍历，若新老节点是同一节点，执行 patch 更新差异；否则，跳出循环 </span>
  <span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e1</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n1</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">[</span><span class="nx">e1</span><span class="p">]</span>
    <span class="kd">const</span> <span class="nx">n2</span> <span class="o">=</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">e2</span><span class="p">]</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">isSameVnodeType</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">patch</span><span class="p">(</span><span class="nx">n1</span><span class="p">,</span> <span class="nx">n2</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">parentAnchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSvg</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="nx">e1</span><span class="o">--</span>
    <span class="nx">e2</span><span class="o">--</span>
  <span class="p">}</span>
  
  <span class="c1">// 仅存在需要新增的节点</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">e1</span><span class="p">)</span> <span class="p">{</span>    
    <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">nextPos</span> <span class="o">=</span> <span class="nx">e2</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="kd">const</span> <span class="nx">anchor</span> <span class="o">=</span> <span class="nx">nextPos</span> <span class="o">&lt;</span> <span class="nx">l2</span> <span class="p">?</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">nextPos</span><span class="p">]</span> <span class="p">:</span> <span class="nx">parentAnchor</span>
      <span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">patch</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">parentAnchor</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="nx">isSvg</span><span class="p">,</span> <span class="nx">optimized</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// 仅存在需要删除的节点</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">e2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">unmount</span><span class="p">(</span><span class="nx">c1</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>    
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// 新旧节点均未遍历完</span>
  <span class="c1">// [i ... e1 + 1]: a b [c d e] f g</span>
  <span class="c1">// [i ... e2 + 1]: a b [e d c h] f g</span>
  <span class="c1">// i = 2, e1 = 4, e2 = 5</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="kd">const</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="c1">// 缓存新 Vnode 剩余节点 上例即{e: 2, d: 3, c: 4, h: 5}</span>
    <span class="kd">const</span> <span class="nx">keyToNewIndexMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">s2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">nextChild</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">optimized</span>
          <span class="p">?</span> <span class="nx">cloneIfMounted</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="k">as</span> <span class="nx">VNode</span><span class="p">)</span>
          <span class="p">:</span> <span class="nx">normalizeVNode</span><span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">nextChild</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">__DEV__</span> <span class="o">&amp;&amp;</span> <span class="nx">keyToNewIndexMap</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">nextChild</span><span class="p">.</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">warn</span><span class="p">(</span>
            <span class="s2">`Duplicate keys found during update:`</span><span class="p">,</span>
             <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">nextChild</span><span class="p">.</span><span class="nx">key</span><span class="p">),</span>
            <span class="s2">`Make sure keys are unique.`</span>
          <span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">keyToNewIndexMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">nextChild</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="c1">// 记录即将 patch 的 新 Vnode 数量</span>
  <span class="kd">let</span> <span class="nx">patched</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="c1">// 新 Vnode 剩余节点长度</span>
  <span class="kd">const</span> <span class="nx">toBePatched</span> <span class="o">=</span> <span class="nx">e2</span> <span class="o">-</span> <span class="nx">s2</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="c1">// 是否移动标识</span>
  <span class="kd">let</span> <span class="nx">moved</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="kd">let</span> <span class="nx">maxNewindexSoFar</span> <span class="o">=</span> <span class="mi">0</span>
  
  <span class="c1">// 初始化 新老节点的对应关系（用于后续最大递增序列算法）</span>
  <span class="kd">const</span> <span class="nx">newIndexToOldIndexMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">toBePatched</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">toBePatched</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">newIndexToOldIndexMap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  
  <span class="c1">// 遍历老 Vnode 剩余节点</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">s1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">e1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">prevChild</span> <span class="o">=</span> <span class="nx">c1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    
    <span class="c1">// 代表当前新 Vnode 都已patch，剩余旧 Vnode 移除即可</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">patched</span> <span class="o">&gt;=</span> <span class="nx">toBePatched</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">unmount</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="p">}</span>
    
    <span class="kd">let</span> <span class="nx">newIndex</span>
    <span class="c1">// 旧 Vnode 存在 key，则从 keyToNewIndexMap 获取</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">prevChild</span><span class="p">.</span><span class="nx">key</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">newIndex</span> <span class="o">=</span> <span class="nx">keyToNewIndexMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
    <span class="c1">// 旧 Vnode 不存在 key，则遍历新 Vnode 获取</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="nx">s2</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">e2</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">newIndexToOldIndexMap</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="nx">s2</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">isSameVNodeType</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">,</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="k">as</span> <span class="nx">VNode</span><span class="p">)){</span>
           <span class="nx">newIndex</span> <span class="o">=</span> <span class="nx">j</span>
           <span class="k">break</span>
        <span class="p">}</span>
      <span class="p">}</span>           
   <span class="p">}</span>
   
   <span class="c1">// 删除、更新节点</span>
   <span class="c1">// 新 Vnode 没有 当前节点，移除</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">newIndex</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">unmount</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">,</span> <span class="nx">parentComponent</span><span class="p">,</span> <span class="nx">parentSuspense</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="c1">// 旧 Vnode 的下标位置 + 1，存储到对应 新 Vnode 的 Map 中</span>
     <span class="c1">// + 1 处理是为了防止数组首位下标是 0 的情况，因为这里的 0 代表需创建新节点</span>
     <span class="nx">newIndexToOldIndexMap</span><span class="p">[</span><span class="nx">newIndex</span> <span class="o">-</span> <span class="nx">s2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span>
     
     <span class="c1">// 若不是连续递增，则代表需要移动</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">newIndex</span> <span class="o">&gt;=</span> <span class="nx">maxNewIndexSoFar</span><span class="p">)</span> <span class="p">{</span>
       <span class="nx">maxNewIndexSoFar</span> <span class="o">=</span> <span class="nx">newIndex</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="nx">moved</span> <span class="o">=</span> <span class="kc">true</span>
     <span class="p">}</span>
     
     <span class="nx">patch</span><span class="p">(</span><span class="nx">prevChild</span><span class="p">,</span><span class="nx">c2</span><span class="p">[</span><span class="nx">newIndex</span><span class="p">],...)</span>
     <span class="nx">patched</span><span class="o">++</span>
   <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// 遍历结束，newIndexToOldIndexMap = {0:5, 1:4, 2:3, 3:0}</span>
  <span class="c1">// 新建、移动节点</span>
  <span class="kd">const</span> <span class="nx">increasingNewIndexSequence</span> <span class="o">=</span> <span class="nx">moved</span>
  <span class="c1">// 获取最长递增序列</span>
  <span class="p">?</span> <span class="nx">getSequence</span><span class="p">(</span><span class="nx">newIndexToOldIndexMap</span><span class="p">)</span>
  <span class="p">:</span> <span class="nx">EMPTY_ARR</span>
  
  <span class="nx">j</span> <span class="o">=</span> <span class="nx">increasingNewIndexSequence</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>

  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">toBePatched</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">nextIndex</span> <span class="o">=</span> <span class="nx">s2</span> <span class="o">+</span> <span class="nx">i</span>
    <span class="kd">const</span> <span class="nx">nextChild</span> <span class="o">=</span> <span class="nx">c2</span><span class="p">[</span><span class="nx">nextIndex</span><span class="p">]</span> <span class="k">as</span> <span class="nx">VNode</span>
    <span class="kd">const</span> <span class="nx">anchor</span> <span class="o">=</span> <span class="nx">extIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">l2</span> <span class="p">?</span> <span class="p">(</span><span class="nx">c2</span><span class="p">[</span><span class="nx">nextIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">as</span> <span class="nx">VNode</span><span class="p">).</span><span class="nx">el</span> <span class="p">:</span> <span class="nx">parentAnchor</span>
    <span class="c1">// 0 新建 Vnode</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">newIndexToOldIndexMap</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">patch</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="nx">nextChild</span><span class="p">,...)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">moved</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 移动节点</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">!==</span> <span class="nx">increasingNewIndexSequence</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">move</span><span class="p">(</span><span class="nx">nextChild</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">anchor</span><span class="p">,</span> <span class="nx">MoveType</span><span class="p">.</span><span class="nx">REORDER</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">j</span><span class="o">--</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></article><div class="post-tail-wrapper"><div class="post-meta mb-3"> <span class="octicon octicon-file-directory mr-1"></span> <a href="https://mfuu.github.io/categories/#Vue" title="Vue">Vue</a></div><div class="share flex align-items-center justify-content-between"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-component" data-disabled='douban,linkedin'> <span class="mr-1">share : </span></div></div></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mfuu/mfuu.github.io" issue-term="title" label="beaudar" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async ></script></div></div><div class="column one-fourth sticky-nav"><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://mfuu.github.io/assets/js/jquery.toc.js"></script></div><script src="https://mfuu.github.io/assets/js/clipboard.min.js"></script> <script defer> (function() { var snippets = document.querySelectorAll('pre'); [].forEach.call(snippets, function(snippet) { snippet.firstChild.insertAdjacentHTML('beforebegin', `<div id="clipboard-copy" aria-label="Copy" class="btn mg-8" data-clipboard-snippet> <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy clipboard-trigger"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path> </svg> <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check clipboard-success"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path> </svg></div>`); }); var clipboardSnippets = new ClipboardJS('[data-clipboard-snippet]', { target: function(trigger) { return trigger.nextElementSibling; } }); clipboardSnippets.on('success', function(e) { e.clearSelection(); showTooltip(e.trigger, 'Copied!'); }); clipboardSnippets.on('error', function(e) { showTooltip(e.trigger, fallbackMessage(e.action)); }); var btns = document.querySelectorAll('.btn'); for (var i = 0; i < btns.length; i++) { btns[i].addEventListener('mouseleave', clearTooltip); btns[i].addEventListener('blur', clearTooltip); } function clearTooltip(e) { e.currentTarget.setAttribute('class', 'btn mg-8'); e.currentTarget.removeAttribute('aria-label'); } function showTooltip(elem, msg) { elem.setAttribute('class', 'btn mg-8 tooltipped tooltipped-w'); elem.setAttribute('aria-label', msg); } function fallbackMessage(action) { var actionMsg = ''; var actionKey = (action === 'cut' ? 'X' : 'C'); if (/iPhone|iPad/i.test(navigator.userAgent)) { actionMsg = 'No support :('; } else if (/Mac/i.test(navigator.userAgent)) { actionMsg = 'Press ⌘-' + actionKey + ' to ' + action; } else { actionMsg = 'Press Ctrl-' + actionKey + ' to ' + action; } return actionMsg; } })(); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer> /** Lazy load images (https://github.com/ApoorvSaxena/lozad.js) and popup when clicked (https://github.com/dimsemenov/Magnific-Popup) */ $(function() { const IMG_SCOPE = 'main > article'; if ($(`${IMG_SCOPE} img`).length <= 0 ) { return; } /* lazy loading */ const imgList = document.querySelectorAll(`${IMG_SCOPE} img[data-src]`); const observer = lozad(imgList); observer.observe(); /* popup */ $(`${IMG_SCOPE} p > img[data-src],${IMG_SCOPE} img[data-src].preview-img`).each( function() { let nextTag = $(this).next(); const title = nextTag.prop('tagName') === 'EM' ? nextTag.text() : ''; const src = $(this).attr('data-src'); // created by lozad.js $(this).wrap(`<a href="${src}" title="${title}" class="popup"></a>`); } ); $('.popup').magnificPopup({ type: 'image', closeOnContentClick: true, showCloseBtn: false, zoom: { enabled: true, duration: 300, easing: 'ease-in-out' } }); /* markup the image links */ $(`${IMG_SCOPE} a`).has('img').addClass('img-link'); }); </script></div></section></main><footer class="site-footer"><div class="contact"><ul class="left"> <a href="https://github.com/mfuu/mfuu.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a> <a class="rss" href="https://mfuu.github.io/feed.xml"> <span class="octicon octicon-rss" title="Subscribe"></span> </a></ul><ul class="right"> <a href="javascript:window.scrollTo(0,0)" class="toTop" title="Scroll to top">TOP</a></ul></div><div class="footer" role="contentinfo"><div class="copyright left"> © 2019 <span title="mfuu">mfuu</span></div><div class="right text-align-right"> <script async src="https://mfuu.github.io/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div> <span id="busuanzi_container_site_pv" style="display:none"> <span id="busuanzi_value_site_pv"></span>浏览 </span> <span id="busuanzi_container_site_uv" style="display:none"> &nbsp;/&nbsp; <span id="busuanzi_value_site_uv"></span>访客 </span></div></div></div></footer><div class="tools-wrapper mobile-hidden"> <a class="gotop" href="#" title="回到顶部"> <svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8=""><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8=""></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8=""></path></svg> </a></div><script src="https://mfuu.github.io/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://mfuu.github.io/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script> <script> jQuery(document).ready(function($) { function setContainerStyle(){ var footerH = $("footer").height(); $('.site-container').css('paddingBottom', `${footerH + 50}px`); } setContainerStyle(); $(window).resize(setContainerStyle()); }); </script></body></html><div class="progress-indicator"></div><script> jQuery(document).ready(function($) { var $w = $(window); var $prog2 = $('.progress-indicator'); var wh = $w.height(); var h = $('body').height(); var sHeight = h - wh; if (!window.requestAnimationFrame) { window.requestAnimationFrame = function(callback){ return setTimeout(callback, 17); }; }; $w.on('scroll', function() { window.requestAnimationFrame(function(){ var perc = Math.max(0, Math.min(1, $w.scrollTop() / sHeight)); updateProgress(perc); }); }); function updateProgress(perc) { $prog2.css({width: perc * 100 + '%'}); } setTimeout(() => { window.toTop && window.toTop() }, 0) }); </script>
