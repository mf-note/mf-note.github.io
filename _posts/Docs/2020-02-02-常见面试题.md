---
layout: post
title: 常见面试题
categories: [面试题]
description: 常见面试题
keywords: 面试题
---



## 从 URL 输入，到页面完全展示，都经历了什么？

总的来说有以下过程：

* DNS 域名解析
* 发起 TCP 连接
* 发送 HTTP 请求
* 服务器处理请求并返回 HTTP 报文
* 浏览器解析渲染页面


### URL 编码， DNS 域名解析

**URL 编码**

网络标准规定 URL 只能是字母和数字，还有一些特殊符号 `（-_.~ ! * ' ( ) ; : @ & = + $ , / ? # [ ]`，如果不进行转义，就会出现歧义（编码规则 utf-8）

**DNS 解析**

DNS 解析就是 URL 和 IP 地址的转换。比如输入地址 `www.google.com`

* 1. 检查浏览器缓存中是否缓存过该域名对应的 IP 地址
* 2. 如果在浏览器缓存中未找到，继续查找本机系统 hosts 是否缓存过 IP
* 3. 向本地域名解析服务器发起域名解析请求
* 4. 向根域名解析服务器发起域名解析请求（`.com`）
* 5. 向顶级域名服务器发起域名解析请求（`google.com`）
* 6. 向主域名服务器发起域名解析请求（`www.google.com`）

1、2 为递归查询，3-6 为迭代查询

**DNS 负载均衡**

DNS 负载均衡的实现原理是在 DNS 服务器中为同一主机名配置多个 IP 地址，在应答 DNS 查询时，DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，也就是返回不同的 IP 地址，从而把访问引导到不同的服务器上去，来达到负载均衡的目的。


### TCP 连接

* URG：紧急标志。 `URG = 1` 时生效
* ACK：确认标志。`ACK = 1`时，确认号字段才有效，TCP 规定，在建立连接后所有报文的传输都必须把 ACK 置为 1
* SYN：同步标志。建立连接时用来同步序号，`SYN = 1, ACK = 0` 时表明是连接请求报文，响应报文中应为 `SYN = 1, ACK = 1`
* FIN：结束标志。用来释放连接，`FIN == 1` 时，表示此报文的发送方的数据已经发送完毕，要求释放

> `ACK` 与 `ack(确认号字段)` 需要区分开

#### 三次握手

![tcp-link](https://user-images.githubusercontent.com/51625532/154204663-c92c4941-069f-40b0-b424-dd76299c6be3.jpg)

* 第一次握手：客户端发送携带 `SYN = 1, Seq = x(x 为随机数)` 的数据包到服务器，进入 `SYN_SEND` 状态，等待服务器确认。（第一次握手由浏览器发起，告诉服务器，我要发送请求了）
* 第二次握手：服务器返回一个带 `SYN = 1, ACK = 1, ack = x + 1, Seq = y` 的响应包，此时服务器进入 `SYN_RECV` 状态。（第二次握手由服务器发起，告诉浏览器准备接收了）
* 第三次握手：客户端收到后会检查 `ack` 是否正确（=== x + 1 ?），如果正确，回传一个带 `ACK = 1, ack = y + 1, Seq = z` 的数据包，客户端和服务器进入 `ESTABLISHED` 状态

> 握手过程中传送的包中不包含数据，三次握手完毕后，客户端和服务器才正式建立连接。

**为什么采用三次握手（TCP 的可靠传输）**

客户端和服务器要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手确认客户端的发送能力；第二次握手 `SYN = 1, Seq = y` 确认了服务器的发送能力，`ACK = x + 1` 确认了服务器的接收能力；第三次握手确认客户端的接收能力。

采用三次握手是为了防止失效的连接请求报文突然又发送给服务器，从而产生错误。例如：客户端发出的连接请求没有收到服务器的确认，于是一段时间后，客户端重新向服务器发送连接请求，并且成功建立连接。此时客户端第一次发送的连接请求并没有丢失，而是因为网络波动导致延迟到达服务器，服务器以为客户端又发起了连接请求，于是同一连接，向客户端发送确认信息，但是客户端并不会理会，服务器就一直等待客户端发送数据，导致资源浪费。

#### 四次挥手

![tcp-close](https://user-images.githubusercontent.com/51625532/154208235-64e2609d-aa90-4a8a-bd92-cd48cd233f8b.jpg)

* 第一次挥手：客户端发送带 `FIN = 1, Seq = u` 的包到服务器，用来关闭客户端到服务器的数据传输，客户端进入 FIN_WAIT_1 状态
* 第二次挥手：服务器收到 FIN 后，发送一个带 `ACK = 1, ack = u + 1, Seq = v` 的包给客户端，确认序号为收到序号 + 1，客户端进入 CLOSE_WAIT 状态
* 第三次挥手：服务器发送一个带 `FIN = 1, ACK = 1, ack = u + 1, Seq = w` 的包给客户端，用来关闭服务器到客户端的数据传输，服务器进入 LAST_ACK 状态
* 第四次挥手：客户端收到 FIN 后进入 TIME_WAIT 状态，接着发送一个带 `ACK = 1, ack = w + 1, Seq = u + 1` 的包给服务器。注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，服务器进入 CLOSED 状态。

**为什么客户端最后要等待2MSL**

* 保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，即保证 TCP 协议的全双工连接能可靠关闭。
* 防止已失效的连接请求报文段出现在本次连接中，即保证本次连接的重复数据段从网络中消失。

### 发送 HTTP 请求

> 强制缓存的优先级高于协商缓存，若两种缓存皆存在，且强制缓存命中目标，则协商缓存不再验证标识

#### HTTP 缓存 ———— 强缓存

缓存命中：

客户端请求数据，如果缓存数据库中有客户端需要的数据并且未过期，则使用缓存中的数据

缓存未命中：

客户端请求数据，如果缓存数据库中的缓存数据失效，则向服务器发起请求，服务器返回数据给客户端，客户端将数据和缓存规则存入缓存系统

**cache-control**

通过 `cache-control` 设置 max-age=xxx 默认为 private

* priate：私有缓存
* public：共享缓存
* max-age：缓存的内容将在 xxx 秒后失效
* no-cahce：需要使用对比缓存来验证缓存数据
* no-store：所有内容都不会缓存，强缓存、协商缓存都不会触发

#### HTTP 缓存 ———— 协商缓存

缓存命中：

客户端从缓存数据库中拿到一个缓存标识，然后向服务器验证缓存标识对应的数据是否失效，如果没有失效服务器会返回304，客户端直接去缓存数据库拿数据。

缓存未命中：

客户端从缓存数据库中拿到一个缓存标识，然后向服务器验证缓存标识对应的数据是否失效，如果失效，服务器返回最新的数据和缓存规则，客户端将数据和缓存规则存入缓存系统

**Last-Modified**

服务器在响应请求时，会告诉浏览器资源的最后修改时间

* if-Modified-Since：浏览器再次请求服务器的时候，请求头会包含该字段，后面跟着在缓存中获得的最后修改时间。服务器收到此请求头发现有 `if-Modified-Since`，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可，如果不一致则返回 200 和新的 `last-modified` 和文件。
* if-Unmodified-Since：从某个时间点算起，资源是否未被修改

**Etag**

服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识

* if-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到报文后发现 `if-None-Match`，则与被请求资源的唯一标识进行对比
  * 不同：说明资源被修改过，响应整个资源内容，返回 200
  * 相同：说明资源未被修改，响应 header，返回 304，浏览器直接从缓存中获取数据


#### 启发式缓存

如果响应中未显示 Expires、Cache-Control: max-age | s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜的寿命。通常会根据响应头中的 Date（创建报文的时间） 减去 Last-Modified（资源最后被修改的时间） 的值的 10% 作为缓存时间


### 服务器处理请求并返回

### 浏览器解析渲染页面



### 参考文章：

[史上最详细的经典面试题 从输入URL到看到页面发生了什么？](https://juejin.cn/post/6844903832435032072)



## V8 引擎的垃圾回收机制


### 垃圾回收策略

v8 的垃圾回收策略主要是基于 `分代式垃圾回收机制`，根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不用的分代采用不同的垃圾回收算法

#### 新生代

#### 老生代

#### 标记清除算法

标记清除算法大致过程：

* 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
* 然后从根对象开始遍历，把不是垃圾的节点改成1
* 清理所有标记为 0 的垃圾，销毁并回收它们所占的内存空间
* 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

优点：

标记清除算法优点只有一个，就是实现比较简单，只需要标记和未标记两种状态

缺点：

在垃圾清除后，剩余的对象内存位置不变，导致空闲内存空间是不连续的，出现了内存碎片。（标记整理算法可以有效解决，在标记结束后，标记整理算法会将活着的对象向内存的一端移动，最后清理掉边界的内存）

#### 引用计数算法

引用计数把对象是否不再需要简化定义为对象有没有其他对象引用到它，如果没有引用指向该对象，对象将被垃圾回收机制回收。它的策略是跟踪记录每个变量被使用的次数

* 当声明了一个变量并且将一个引用类型赋值给变量的时候，这个值的引用次数就为 1
* 如果同一个值又被赋给另一个变量，那么引用次数加 1
* 如果该变量的值被其他的值覆盖，引用次数减 1
* 当变量的引用次数为 0 时，说明这个值没被访问，垃圾回收器在运行时会清理掉引用次数为 0 的值占的内存

优点：

引用值为 0 时就会被回收，不需要像标记清除算法每隔一段时间进行一次；标记清除算法需要遍历堆里的活动和非活动对象，引用计数只需要在引用时计算引用次数即可

缺点：

无法解决循环引用问题；需要一个计数器，需要占很大的位置


----

## 二叉树的深度遍历和广度遍历

### 深度优先遍历

深度优先遍历包括：

* 先序遍历，先访问根节点，然后访问左节点，最后访问右节点
* 中序遍历，先访问左节点，然后访问根节点，最后访问右节点
* 后序遍历，先访问左节点，然后访问右节点，最后访问根节点

先序遍历可以用来显示目录结构等；中序遍历可以实现表达式树，在编译底层很有用；后序遍历可以用来实现计算机目录内的文件及其信息等。

#### 先序遍历

* 递归
  ```js
  function dfs(root) {
    if (root) {
      console.log(root)
      dfs(root.left)
      dfs(root.right)
    }
  }
  ```

* 非递归
  ```js
  function dfs(root) {
    if (root) {
      const stack = [root]
      while(stack.length) {
        root = stack.pop() // 取出栈顶元素
        console.log(root)
        // 因为先序遍历是先左后右，栈是先进后出结构
        // 所以先 push 右边再 push 左边
        if (root.right) stack.push(root.right)
        if (root.left) stack.push(root.left)
      }
    }
  }
  ```

#### 中序遍历

* 递归
  ```js
  function dfs(root) {
    if (root) {
      dfs(root.left)
      console.log(root)
      dfs(root.right)
    }
  }
  ```

* 非递归
  ```js
  function dfs(root) {
    if (root) {
      const stack = []
      // 中序遍历是先左再根最后右
      // 所以⾸先应该先把最左边节点遍历到底依次 push 进栈
      // 当左边没有节点时，就打印栈顶元素，然后寻找右节点
      // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的⽗节点
      // 左边打印不出东⻄就把⽗节点拿出来打印，然后再看右节点
      while(stack.length || root) {
        if (root) {
          stack.push(root)
          root = root.left
        } else {
          root = stack.pop()
          console.log(root)
          root = root.right
        }
      }
    }
  }
  ```

#### 后序遍历

* 递归
  ```js
  function dfs(root) {
    if (root) {
      dfs(root.left)
      dfs(root.right)
      console.log(root)
    }
  }
  ```
* 非递归
  ```js
  function dfs(root) {
    if (root) {
      const stack1 = []
      const stack2 = []
      stack1.push(root)
      while(stack1.length) {
        root = stack1.pop()
        stack2.push(root)
        if (root.left) stack1.push(root.left)
        if (root.right) stack1.push(root.right)
      }
      while(stack2.length) {
        console.log(stack2.pop())
      }
    }
  }
  ```


### 广度优先遍历

广度遍历是从二叉树的根结点开始，自上而下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问

* 递归
  ```js
  
  ```

* 非递归
  ```js
  function bfs(root) {
    const queue = [node]
    while(queue.length) {
      root = queue.shift()
      console.log(root.value)
      if (root.left) queue.push(root.left)
      if (root.right) queue.push(root.right)
    }
  }
  ```

## HTTP2.0

### 与 HTTP1.x 相比的新特性

> 二进制传输

HTTP 2.0 中所有加强性能的核心点在于此。在此之前的 HTTP 版本中，都是通过文本的方式传输数据，在 HTTP 2.0 中引入了新的编码机制，所有的传输数据都会被分割，并采用二进制格式编码。

> 多路复用

一次TCP握手，多个同域并行请求，请求和响应同时发送接受，然后再拼装组合，不阻塞；一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

>  header 压缩

在 HTTP 1.x 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

> 服务器推送

据客户端需求，服务端主动推送资源，减少请求耗时。

## React 与 Vue 的区别

### 数据

* React 整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在 React 中，是单向数据流，推崇结合 `immutable` 来实现数据不可变。React 在 `setState` 之后会重新走渲染的流程，如果 `shouldComponentUpdate` 返回的是 `true`，就继续渲染，如果是 `false`，就不会重新渲染。`PureComponent` 就是重写了 `shouldComponentUpdate`，然后在里面做了 props 和 state 的浅层对比。

* Vue 的思想是响应式的，也就是基于数据可变。通过对每一个属性建立 Watcher 来监听，当属性变化时，响应式的更新对应的虚拟 dom。

总的来说，React 的性能优化需要手动去做，而 Vue 的性能优化是自动的，但是 Vue 的响应式机制也有问题，当 state 特别多的时候，Watcher 也会很多，会导致卡顿。

### 模板和 JSX

* React 的思路是全部通过 js 来实现，通过 js 来生成 html，所以设计了 JSX，还有通过 js 来操作 css（styled-component、jss 等）

* Vue 是把 html、css、js 组合到一起，用各自的处理方式，Vue 有单文件组件，可以把 html、css、js 写到一个文件中，html 提供了模板引擎来处理

### 组件


### 总结

React 整体的思路就是函数式，所以推崇纯组件，数据不可变，单向数据流。
Vue 是基于可变数据，支持双向绑定。


## TypeScript 与 JavaScript 的区别

## Event Loop

1. 代码开始执行，创建一个全局调用栈，script作为宏任务执行
2. 执行过程过同步任务立即执行，异步任务根据异步任务类型分别注册到微任务队列和宏任务队列
3. 同步任务执行完毕，查看微任务队列
4. 若存在微任务，将微任务队列全部执行(包括执行微任务过程中产生的新微任务)
5. 若无微任务，查看宏任务队列，执行第一个宏任务，宏任务执行完毕，查看微任务队列，重复上述操作，直至宏任务队列为空

* [深入理解js事件循环机制（Node.js）](https://github.com/mf-note/Blog/issues/2)
* [深入理解js事件循环机制（浏览器）](https://github.com/mf-note/Blog/issues/3)

## Vue 创建到销毁的全过程