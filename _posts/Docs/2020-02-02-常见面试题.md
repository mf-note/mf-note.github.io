---
layout: post
title: 常见面试题
categories: [面试题]
description: 常见面试题
keywords: 面试题
---



## 从 URL 输入，到页面完全展示，都经历了什么？

总的来说有以下过程：

* DNS 域名解析
* 发起 TCP 连接
* 发送 HTTP 请求
* 服务器处理请求并返回 HTTP 报文
* 浏览器解析渲染页面


### URL 编码， DNS 域名解析

**URL 编码**

网络标准规定 URL 只能是字母和数字，还有一些特殊符号 `（-_.~ ! * ' ( ) ; : @ & = + $ , / ? # [ ]`，如果不进行转义，就会出现歧义（编码规则 utf-8）

**DNS 解析**

DNS 解析就是 URL 和 IP 地址的转换。比如输入地址 `www.google.com`

* 1. 检查浏览器缓存中是否缓存过该域名对应的 IP 地址
* 2. 如果在浏览器缓存中未找到，继续查找本机系统 hosts 是否缓存过 IP
* 3. 向本地域名解析服务器发起域名解析请求
* 4. 向根域名解析服务器发起域名解析请求（`.com`）
* 5. 向顶级域名服务器发起域名解析请求（`google.com`）
* 6. 向主域名服务器发起域名解析请求（`www.google.com`）

1、2 为递归查询，3-6 为迭代查询

**DNS 负载均衡**

DNS 负载均衡的实现原理是在 DNS 服务器中为同一主机名配置多个 IP 地址，在应答 DNS 查询时，DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，也就是返回不同的 IP 地址，从而把访问引导到不同的服务器上去，来达到负载均衡的目的。


### TCP 连接

* URG：紧急标志。 `URG = 1` 时生效
* ACK：确认标志。`ACK = 1`时，确认号字段才有效，TCP 规定，在建立连接后所有报文的传输都必须把 ACK 置为 1
* SYN：同步标志。建立连接时用来同步序号，`SYN = 1, ACK = 0` 时表明是连接请求报文，响应报文中应为 `SYN = 1, ACK = 1`
* FIN：结束标志。用来释放连接，`FIN == 1` 时，表示此报文的发送方的数据已经发送完毕，要求释放

> `ACK` 与 `ack(确认号字段)` 需要区分开

#### 三次握手

![tcp-link](https://user-images.githubusercontent.com/51625532/154204663-c92c4941-069f-40b0-b424-dd76299c6be3.jpg)

* 第一次握手：客户端发送携带 `SYN = 1, Seq = x(x 为随机数)` 的数据包到服务器，进入 `SYN_SEND` 状态，等待服务器确认。（第一次握手由浏览器发起，告诉服务器，我要发送请求了）
* 第二次握手：服务器返回一个带 `SYN = 1, ACK = 1, ack = x + 1, Seq = y` 的响应包，此时服务器进入 `SYN_RECV` 状态。（第二次握手由服务器发起，告诉浏览器准备接收了）
* 第三次握手：客户端收到后会检查 `ack` 是否正确（=== x + 1 ?），如果正确，回传一个带 `ACK = 1, ack = y + 1, Seq = z` 的数据包，客户端和服务器进入 `ESTABLISHED` 状态

> 握手过程中传送的包中不包含数据，三次握手完毕后，客户端和服务器才正式建立连接。

**为什么采用三次握手（TCP 的可靠传输）**

客户端和服务器要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手确认客户端的发送能力；第二次握手 `SYN = 1, Seq = y` 确认了服务器的发送能力，`ACK = x + 1` 确认了服务器的接收能力；第三次握手确认客户端的接收能力。

采用三次握手是为了防止失效的连接请求报文突然又发送给服务器，从而产生错误。例如：客户端发出的连接请求没有收到服务器的确认，于是一段时间后，客户端重新向服务器发送连接请求，并且成功建立连接。此时客户端第一次发送的连接请求并没有丢失，而是因为网络波动导致延迟到达服务器，服务器以为客户端又发起了连接请求，于是同一连接，向客户端发送确认信息，但是客户端并不会理会，服务器就一直等待客户端发送数据，导致资源浪费。

#### 四次挥手

![tcp-close](https://user-images.githubusercontent.com/51625532/154208235-64e2609d-aa90-4a8a-bd92-cd48cd233f8b.jpg)

* 第一次挥手：客户端发送带 `FIN = 1, Seq = u` 的包到服务器，用来关闭客户端到服务器的数据传输，客户端进入 FIN_WAIT_1 状态
* 第二次挥手：服务器收到 FIN 后，发送一个带 `ACK = 1, ack = u + 1, Seq = v` 的包给客户端，确认序号为收到序号 + 1，客户端进入 CLOSE_WAIT 状态
* 第三次挥手：服务器发送一个带 `FIN = 1, ACK = 1, ack = u + 1, Seq = w` 的包给客户端，用来关闭服务器到客户端的数据传输，服务器进入 LAST_ACK 状态
* 第四次挥手：客户端收到 FIN 后进入 TIME_WAIT 状态，接着发送一个带 `ACK = 1, ack = w + 1, Seq = u + 1` 的包给服务器。注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，服务器进入 CLOSED 状态。

**为什么客户端最后要等待2MSL**

* 保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，即保证 TCP 协议的全双工连接能可靠关闭。
* 防止已失效的连接请求报文段出现在本次连接中，即保证本次连接的重复数据段从网络中消失。

### 发送 HTTP 请求

> 强制缓存的优先级高于协商缓存，若两种缓存皆存在，且强制缓存命中目标，则协商缓存不再验证标识

#### HTTP 缓存 ———— 强缓存

缓存命中：

客户端请求数据，如果缓存数据库中有客户端需要的数据并且未过期，则使用缓存中的数据

缓存未命中：

客户端请求数据，如果缓存数据库中的缓存数据失效，则向服务器发起请求，服务器返回数据给客户端，客户端将数据和缓存规则存入缓存系统

**cache-control**

通过 `cache-control` 设置 max-age=xxx 默认为 private

* priate：私有缓存
* public：共享缓存
* max-age：缓存的内容将在 xxx 秒后失效
* no-cahce：需要使用对比缓存来验证缓存数据
* no-store：所有内容都不会缓存，强缓存、协商缓存都不会触发

#### HTTP 缓存 ———— 协商缓存

缓存命中：

客户端从缓存数据库中拿到一个缓存标识，然后向服务器验证缓存标识对应的数据是否失效，如果没有失效服务器会返回304，客户端直接去缓存数据库拿数据。

缓存未命中：

客户端从缓存数据库中拿到一个缓存标识，然后向服务器验证缓存标识对应的数据是否失效，如果失效，服务器返回最新的数据和缓存规则，客户端将数据和缓存规则存入缓存系统

**Last-Modified**

服务器在响应请求时，会告诉浏览器资源的最后修改时间

* if-Modified-Since：浏览器再次请求服务器的时候，请求头会包含该字段，后面跟着在缓存中获得的最后修改时间。服务器收到此请求头发现有 `if-Modified-Since`，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可，如果不一致则返回 200 和新的 `last-modified` 和文件。
* if-Unmodified-Since：从某个时间点算起，资源是否未被修改

**Etag**

服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识

* if-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到报文后发现 `if-None-Match`，则与被请求资源的唯一标识进行对比
  * 不同：说明资源被修改过，响应整个资源内容，返回 200
  * 相同：说明资源未被修改，响应 header，返回 304，浏览器直接从缓存中获取数据


#### 启发式缓存

如果响应中未显示 Expires、Cache-Control: max-age | s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜的寿命。通常会根据响应头中的 Date（创建报文的时间） 减去 Last-Modified（资源最后被修改的时间） 的值的 10% 作为缓存时间


### 服务器处理请求并返回

### 浏览器解析渲染页面



### 参考文章：

[史上最详细的经典面试题 从输入URL到看到页面发生了什么？](https://juejin.cn/post/6844903832435032072)



## V8 引擎的垃圾回收机制


### 垃圾回收策略

v8 的垃圾回收策略主要是基于 `分代式垃圾回收机制`，根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不用的分代采用不同的垃圾回收算法

#### 新生代

#### 老生代

#### 标记清除算法

标记清除算法大致过程：

* 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
* 然后从根对象开始遍历，把不是垃圾的节点改成1
* 清理所有标记为 0 的垃圾，销毁并回收它们所占的内存空间
* 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

优点：

标记清除算法优点只有一个，就是实现比较简单，只需要标记和未标记两种状态

缺点：

在垃圾清除后，剩余的对象内存位置不变，导致空闲内存空间是不连续的，出现了内存碎片。（标记整理算法可以有效解决，在标记结束后，标记整理算法会将活着的对象向内存的一端移动，最后清理掉边界的内存）

#### 引用计数算法

引用计数把对象是否不再需要简化定义为对象有没有其他对象引用到它，如果没有引用指向该对象，对象将被垃圾回收机制回收。它的策略是跟踪记录每个变量被使用的次数

* 当声明了一个变量并且将一个引用类型赋值给变量的时候，这个值的引用次数就为 1
* 如果同一个值又被赋给另一个变量，那么引用次数加 1
* 如果该变量的值被其他的值覆盖，引用次数减 1
* 当变量的引用次数为 0 时，说明这个值没被访问，垃圾回收器在运行时会清理掉引用次数为 0 的值占的内存

优点：

引用值为 0 时就会被回收，不需要像标记清除算法每隔一段时间进行一次；标记清除算法需要遍历堆里的活动和非活动对象，引用计数只需要在引用时计算引用次数即可

缺点：

无法解决循环引用问题；需要一个计数器，需要占很大的位置


----

## 二叉树的深度遍历和广度遍历

### 深度优先遍历

深度优先遍历包括：

* 先序遍历，先访问根节点，然后访问左节点，最后访问右节点
* 中序遍历，先访问左节点，然后访问根节点，最后访问右节点
* 后序遍历，先访问左节点，然后访问右节点，最后访问根节点

先序遍历可以用来显示目录结构等；中序遍历可以实现表达式树，在编译底层很有用；后序遍历可以用来实现计算机目录内的文件及其信息等。

#### 先序遍历

* 递归
  ```js
  function dfs(root) {
    if (root) {
      console.log(root)
      dfs(root.left)
      dfs(root.right)
    }
  }
  ```

* 非递归
  ```js
  function dfs(root) {
    if (root) {
      const stack = [root]
      while(stack.length) {
        root = stack.pop() // 取出栈顶元素
        console.log(root)
        // 因为先序遍历是先左后右，栈是先进后出结构
        // 所以先 push 右边再 push 左边
        if (root.right) stack.push(root.right)
        if (root.left) stack.push(root.left)
      }
    }
  }
  ```

#### 中序遍历

* 递归
  ```js
  function dfs(root) {
    if (root) {
      dfs(root.left)
      console.log(root)
      dfs(root.right)
    }
  }
  ```

* 非递归
  ```js
  function dfs(root) {
    if (root) {
      const stack = []
      // 中序遍历是先左再根最后右
      // 所以⾸先应该先把最左边节点遍历到底依次 push 进栈
      // 当左边没有节点时，就打印栈顶元素，然后寻找右节点
      // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的⽗节点
      // 左边打印不出东⻄就把⽗节点拿出来打印，然后再看右节点
      while(stack.length || root) {
        if (root) {
          stack.push(root)
          root = root.left
        } else {
          root = stack.pop()
          console.log(root)
          root = root.right
        }
      }
    }
  }
  ```

#### 后序遍历

* 递归
  ```js
  function dfs(root) {
    if (root) {
      dfs(root.left)
      dfs(root.right)
      console.log(root)
    }
  }
  ```
* 非递归
  ```js
  function dfs(root) {
    if (root) {
      const stack1 = []
      const stack2 = []
      stack1.push(root)
      while(stack1.length) {
        root = stack1.pop()
        stack2.push(root)
        if (root.left) stack1.push(root.left)
        if (root.right) stack1.push(root.right)
      }
      while(stack2.length) {
        console.log(stack2.pop())
      }
    }
  }
  ```


### 广度优先遍历

广度遍历是从二叉树的根结点开始，自上而下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问

* 递归
  ```js
  
  ```

* 非递归
  ```js
  function bfs(root) {
    const queue = [node]
    while(queue.length) {
      root = queue.shift()
      console.log(root.value)
      if (root.left) queue.push(root.left)
      if (root.right) queue.push(root.right)
    }
  }
  ```

## HTTP2.0

### 与 HTTP1.x 相比的新特性

> 二进制传输

HTTP 2.0 中所有加强性能的核心点在于此。在此之前的 HTTP 版本中，都是通过文本的方式传输数据，在 HTTP 2.0 中引入了新的编码机制，所有的传输数据都会被分割，并采用二进制格式编码。

> 多路复用

在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求（在一个 TCP 上并行地发送任意数量 HTTP 请求），对端可以通过帧中的标识知道属于哪个请求。通过这种技术，可以避免 HTTP 旧版本中的对头阻塞问题，极大的提高传输性能。这个强大的功能则是基于“二进制分帧”的特性。

>  header 压缩

在 HTTP 1.x 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

> 服务器推送

允许服务器在发送页面 HTML 时主动推送其他资源，而不用等到浏览器解析到相应位置，发起请求再响应。

例如：服务端主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。

服务器可以主动推送，客户端也可以选择是否接收。

## React 与 Vue 的区别

### 数据

* React 整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在 React 中，是单向数据流，推崇结合 `immutable` 来实现数据不可变。React 在 `setState` 之后会重新走渲染的流程，如果 `shouldComponentUpdate` 返回的是 `true`，就继续渲染，如果是 `false`，就不会重新渲染。`PureComponent` 就是重写了 `shouldComponentUpdate`，然后在里面做了 props 和 state 的浅层对比。

* Vue 的思想是响应式的，也就是基于数据可变。通过对每一个属性建立 Watcher 来监听，当属性变化时，响应式的更新对应的虚拟 dom。

总的来说，React 的性能优化需要手动去做，而 Vue 的性能优化是自动的，但是 Vue 的响应式机制也有问题，当 state 特别多的时候，Watcher 也会很多，会导致卡顿。

### 模板和 JSX

* React 的思路是全部通过 js 来实现，通过 js 来生成 html，所以设计了 JSX，还有通过 js 来操作 css（styled-component、jss 等）

* Vue 是把 html、css、js 组合到一起，用各自的处理方式，Vue 有单文件组件，可以把 html、css、js 写到一个文件中，html 提供了模板引擎来处理

### Diff 算法不同


### 响应式原理不同

* React 的响应式原理：通过 `setState()` 方法来更新状态，状态更新后，组件也会重新渲染

* Vue 的响应式原理：Vue 会遍历 data 数据对象，使用 `Object.definedProperty()` 将每个属性转为 `getter` 和 `setter`，每个 Vue 组件实例都有一个对应的 watcher 实例，在组件初次渲染的时候会记录组件用到了哪些数据，当数据发生变化时，会触发 `setter` 方法，并通知所有依赖这个数据的 watcher 实例调用 `update` 方法去触发组件的 `compile` 渲染方法，进行数据渲染

### 总结

React 整体的思路就是函数式，所以推崇纯组件，数据不可变，单向数据流。
Vue 是基于可变数据，支持双向绑定。


## TypeScript 与 JavaScript 的区别

### TypeScript 的特点

相较于JS（ES6+）

* TS 是 JS 的超集，即你可以在 TS 中使用原生 JS 语法
* TS 需要静态编译，它提供了强类型与更多面向对象的内容
* TS 最终仍需要编译为弱类型的 JS 文件，基于对象的原生 JS，再运行

### 区别

| JavaScript | TypeScript |
| ---------- | ---------- |
| **动态类型**，运行时明确变量的类型，变量的类型由变量的值决定，并跟随值的变化改变 | **静态类型**，声明时确定类型，之后不允许修改 |
| **直接运行**在浏览器和 node 环境中 | **编译运行**，始终先编译成 JavaScript 再运行 |
| **弱类型**，数据类型可以被忽略，一个变量可以赋不同数据类型的值 | **强类型**，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型 |
## Event Loop

1. 代码开始执行，创建一个全局调用栈，script作为宏任务执行
2. 执行过程过同步任务立即执行，异步任务根据异步任务类型分别注册到微任务队列和宏任务队列
3. 同步任务执行完毕，查看微任务队列
4. 若存在微任务，将微任务队列全部执行(包括执行微任务过程中产生的新微任务)
5. 若无微任务，查看宏任务队列，执行第一个宏任务，宏任务执行完毕，查看微任务队列，重复上述操作，直至宏任务队列为空

* [深入理解js事件循环机制（Node.js）](https://github.com/mfuu/Blog/issues/2)
* [深入理解js事件循环机制（浏览器）](https://github.com/mfuu/Blog/issues/3)

## Vue 创建到销毁的全过程

### 初始化

#### `new Vue()`

这个阶段做的第一件事就是 `new` 创建一个 `Vue` 实例对象

```js
new Vue({
  el: '#app',
  render: h => h(App)
})
```

源码地址：`src/core/instance/index.js`

```js
function Vue (options) {
  ...
  this._init(options)
}
initMixin(Vue)
```

#### `_init()`

源码地址：`src/core/instance/init.js`

主要流程：

* 合并配置，把一些内置组件 `<component />`、`<keep-alive />`、`<transition />`、`directive`、`filter` 等合并到 Vue.optoins
* 调用一些初始化函数
* 触发生命周期钩子，`beforeCreate` 和 `created`
* 最后调用 `$mount` 挂载，进入下一阶段

```js
export function initMixin(Vue: typeof Component) {
  // 在原型上添加 _init 方法
  Vue.prototype._init = function (options?: Record<string, any>) {
    // 保存当前实例
    const vm: Component = this

    ...

    // merge options
    if (options && options._isComponent) {
      // 把子组件依赖父组件的 props, listeners 挂载到 options 上，并指定组件的 $options
      initInternalComponent(vm, options as any)
    } else {
      // 把传进来的 options 和当前构造函数和父级的 options 进行合并，并挂载到原型上
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor as any),
        options || {},
        vm
      )
    }
    ...
    // expose real self
    vm._self = vm
    initLifecycle(vm) // 初始化实例的属性、数据：$options, $children, $refs, $root, _watcher ...等
    initEvents(vm) // 初始化事件：$on, $off, $emit, $once
    initRender(vm) // 初始化渲染：render, mixin
    callHook(vm, 'beforeCreate')
    initInjections(vm) // 初始化 inject
    initState(vm) // 初始化组件数据：props、data、methods、watch、computed
    initProvide(vm) // 初始化 provide
    callHook(vm, 'created') // 调用声明周期钩子函数

    ...

    if (vm.$options.el) {
      // 如果传了 el 就会调用 $mount 进入模板编译和挂载阶段
      // 如果没有传就需要手动执行 $mount 才会进入下一阶段
      vm.$mount(vm.$options.el)
    }
  }
}
```

### 模板编译阶段

#### `$mount`

源码地址：`dist/vue.js - 11927`

```js
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  ...

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          ...
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (__DEV__) {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      // @ts-expect-error
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (__DEV__ && config.performance && mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: __DEV__,
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        },
        this
      )
      options.render = render
      options.staticRenderFns = staticRenderFns

      ...
    }
  }
  return mount.call(this, el, hydrating)
}
```

`$mount` 主要就是判断要不要编译，使用哪一个模板编译

### 挂载阶段

这个阶段主要做的事有两件

* 根据 render 返回的虚拟 DOM 创建真实的 DOM 节点，插入到视图中，完成渲染
* 对模板中数据或状态做响应式处理

#### `mountComponent()`


这里主要做的就是

* 调用钩子函数 `beforeMount`
* 调用 `_update()` 方法对新老虚拟 DOM 进行 `patch` 以及 `new Watcher` 对模板数据做响应式处理
* 再调钩子函数 `mounted`

源码地址：`src/core/instance/lifecycle.js - 139`

```js
export function mountComponent(
  vm: Component,
  el: Element | null | undefined,
  hydrating?: boolean
): Component {
  vm.$el = el
  // 判断有没有渲染函数 render
  if (!vm.$options.render) {
    // 如果没有，默认创建一个注释节点
    vm.$options.render = createEmptyVNode
  }
  callHook(vm, 'beforeMount')

  let updateComponent
  updateComponent = () => {
    // 调用 _update 对 render 返回的虚拟 DOM 进行 patch（也就是 Digg）到真实 DOM，这里是首次渲染
    vm._update(vm._render(), hydrating)
  }

  const watcherOptions: WatcherOptions = {
    // 触发更新时，会在更新之前调用
    before() {
      // 判断 DOM 是否是挂载状态，就是说首次渲染和卸载的时候不执行
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }

  // 为当前组件实例设置观察者，监控 updateComponent 函数得到的数据
  new Watcher(
    vm,
    updateComponent,
    noop,
    watcherOptions,
    true /* isRenderWatcher */
  )
  hydrating = false

  // 没有旧 vnode，说明是首次渲染
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

#### `Watcher`

#### `_update()`

源码地址：`src/core/instance/lifecycle.js - 62`

```js
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el // 当前组件根节点
  const prevVnode = vm._vnode // 旧的 vnode
  const restoreActiveInstance = setActiveInstance(vm)
  vm._vnode = vnode // 更新旧的 vnode
  // 如果是首次渲染
  if (!prevVnode) {
    // 对 vnode 进行 patch 创建真实的 DOM，挂载到 vm.$el 上
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // 修改的时候，进行新旧 vnode 对比
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  restoreActiveInstance()
  // 删除旧根节点的引用
  if (prevEl) {
    prevEl.__vue__ = null
  }
  // 更新当前根节点的引用
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }
  // 更新父级的引用
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
}
```

### 销毁阶段

#### `$destroy()`

* 调用生命周期钩子函数 `beforeDestroy`
* 从父组件中删除当前组件
* 移除当前组件内的所有观察者（依赖追踪），删除数据对象的引用，删除虚拟 DOM
* 调用生命周期钩子函数 `destroyed`
* 关闭所有事件监听，删除当前跟组件的引用，删除父级的引用

源码地址：`src/core/instance/lifecycle.js - 100`

```js
Vue.prototype.$destroy = function () {
  const vm: Component = this
  // 如果实例正在被销毁的过程中，直接跳过
  if (vm._isBeingDestroyed) {
    return
  }
  callHook(vm, 'beforeDestroy')
  // 更新销毁状态
  vm._isBeingDestroyed = true
  // remove self from parent
  const parent = vm.$parent
  // 如果父级存在，并且父级没有在被销毁，并且不是抽象组件而是真实组件（<keep-alive>就是抽象组件，它的 abstract 为 true）
  if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
    // 从父组件中删除
    remove(parent.$children, vm)
  }
  // teardown scope. this includes both the render watcher and other
  // watchers created
  vm._scope.stop()
  // remove reference from data ob
  // frozen object may not have observer.
  if (vm._data.__ob__) {
    vm._data.__ob__.vmCount--
  }
  // call the last hook...
  vm._isDestroyed = true
  // 删除实例的虚拟 DOM
  vm.__patch__(vm._vnode, null)
  // fire destroyed hook
  callHook(vm, 'destroyed')
  // turn off all instance listeners.
  vm.$off()
  // 删除当前跟组件的引用
  if (vm.$el) {
    vm.$el.__vue__ = null
  }
  // 删除父级的引用
  if (vm.$vnode) {
    vm.$vnode.parent = null
  }
}
```

#### 什么时候调用 `$destroy()`

* 新的 vnode 不存在，旧的 vnode 存在时，触发卸载旧 vnode 对应组件的 destroy
* 新的 vnode 根节点被修改时，调用旧 vnode 对应组件的 destroy
* 新旧 vnode 对比结束后，调用旧 vnode 对应组件的 destroy

## 手动实现 EventBus

https://developer.aliyun.com/article/975490